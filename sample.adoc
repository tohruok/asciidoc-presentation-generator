= プレゼンテーションタイトル
:author: Your Name
:email: your.email@example.com
:revdate: {docdate}
:doctype: book
:backend: revealjs
:revealjsdir: https://cdn.jsdelivr.net/npm/reveal.js@5.1.0
:revealjs_theme: white
:revealjs_transition: slide
:revealjs_slideNumber: true
:revealjs_hash: true
:source-highlighter: highlight.js
:icons: font
:pdf-theme: japanese
:pdf-themesdir: themes
:chapter-label: 章

++++
<style>
.reveal h1 { font-size: 1.8em !important; line-height: 1.2; margin-bottom: 0.5em; }
.reveal h2 { font-size: 1.4em !important; line-height: 1.3; margin-bottom: 0.4em; }
.reveal h3 { font-size: 1.2em !important; line-height: 1.3; margin-bottom: 0.3em; }
.reveal .title h1 { font-size: 2.2em !important; margin-bottom: 0.5em; }
.reveal pre code { font-size: 0.6em !important; line-height: 1.3; max-height: 500px; }
.reveal table { font-size: 0.8em !important; }
.reveal ul, .reveal ol { font-size: 0.9em; }
.reveal .slide-number { font-size: 0.4em; left: 50px !important; width: 50px !important;}
</style>
++++

== はじめに

[.notes]
--
これは発表者ノートです。
スライドの補足説明をここに書きます。
--

=== 自己紹介

* 名前: Your Name
* 所属: Your Company
* 役職: Your Role

== アジェンダ

[%step]
* 第1章: 問題の背景
* 第2章: 解決策の提案  
* 第3章: 実装方法
* 第4章: 結果と評価



== 第1章: 問題の背景

=== 現在の課題

[.fragment]
課題1:: 効率性の問題

[.fragment]
課題2:: コストの問題

[.fragment]
課題3:: 品質の問題

=== データで見る現状

[cols="2*", options="header"]
|===
|指標 |現在の値

|効率
|60%

|コスト
|120%

|品質スコア
|3.2/5.0
|===



== 第2章: 解決策の提案

=== 提案する解決策

.システムアーキテクチャ図
[mermaid]
----
graph TB
    subgraph "フロントエンド"
        A[React App]
        B[TypeScript]
        C[Tailwind CSS]
    end
    
    subgraph "バックエンド"
        D[Node.js API]
        E[Express Server]
        F[認証サービス]
    end
    
    subgraph "データベース"
        G[PostgreSQL]
        H[Redis Cache]
    end
    
    subgraph "外部サービス"
        I[AWS S3]
        J[Email Service]
    end
    
    A -->|HTTP/REST| D
    D -->|SQL| G
    D -->|キャッシュ| H
    D -->|ファイル保存| I
    D -->|通知送信| J
    F -->|ユーザー情報| G
    
    style A fill:#e1f5fe
    style D fill:#f3e5f5
    style G fill:#e8f5e8
    style I fill:#fff3e0
----

[.notes]
--
この図は提案するシステムの全体アーキテクチャを示しています。
フロントエンドからバックエンドAPI、データベース、外部サービスまでの
データフローを可視化しています。
--

=== プロセスフロー

.業務プロセスフロー
[mermaid]
----
flowchart TD
    A[要求受付] --> B{要求の種類}
    B -->|新規機能| C[機能設計]
    B -->|バグ修正| D[問題分析]
    B -->|改善提案| E[現状調査]
    
    C --> F[開発チーム割当]
    D --> F
    E --> F
    
    F --> G[実装開始]
    G --> H[テスト実行]
    H --> I{テスト結果}
    
    I -->|合格| J[デプロイ準備]
    I -->|不合格| K[修正作業]
    K --> H
    
    J --> L[本番環境デプロイ]
    L --> M[動作確認]
    M --> N[完了]
    
    style A fill:#e1f5fe
    style N fill:#c8e6c9
    style K fill:#ffcdd2
----

=== 技術スタック

[source,yaml]
----
frontend:
  - React
  - TypeScript
  - Tailwind CSS

backend:
  - Node.js
  - Express
  - PostgreSQL
----

=== 実装サンプル（Java）

.REST APIコントローラー
[source,java]
----
@RestController
@RequestMapping("/api/users")
@Slf4j
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
        try {
            UserDto user = userService.findById(id);
            return ResponseEntity.ok(user);
        } catch (UserNotFoundException e) {
            log.error("User not found: {}", id, e);
            return ResponseEntity.notFound().build();
        }
    }
    
    @PostMapping
    public ResponseEntity<UserDto> createUser(@Valid @RequestBody CreateUserRequest request) {
        UserDto createdUser = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
}
----

.サービス層の実装
[source,java]
----
@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    @Transactional(readOnly = true)
    public UserDto findById(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException("User not found: " + id));
        
        return UserDto.builder()
            .id(user.getId())
            .username(user.getUsername())
            .email(user.getEmail())
            .createdAt(user.getCreatedAt())
            .build();
    }
    
    public UserDto create(CreateUserRequest request) {
        // パスワードをハッシュ化
        String hashedPassword = passwordEncoder.encode(request.getPassword());
        
        User user = User.builder()
            .username(request.getUsername())
            .email(request.getEmail())
            .password(hashedPassword)
            .build();
            
        User savedUser = userRepository.save(user);
        
        return convertToDto(savedUser);
    }
}
----



== 第3章: 実装方法

=== 実装タイムライン

.プロジェクトスケジュール
[cols="3,2,2,2", options="header"]
|===
|タスク |期間 |状態 |担当

|環境構築
|2024/01/01 - 01/15
|完了
|インフラチーム

|基本機能実装
|2024/01/16 - 02/15
|完了
|開発チーム

|テスト環境構築
|2024/02/01 - 02/15
|完了
|QAチーム

|高度機能開発
|2024/02/16 - 03/31
|進行中
|開発チーム

|パフォーマンス最適化
|2024/03/15 - 04/15
|予定
|技術チーム

|セキュリティ強化
|2024/04/01 - 04/30
|予定
|セキュリティチーム

|本番環境準備
|2024/04/15 - 05/01
|予定
|インフラチーム

|リリース
|2024/05/01 - 05/15
|予定
|全チーム
|===

=== システム構成図

.インフラストラクチャ構成
[mermaid]
----
graph TD
    A[CDN<br/>CloudFlare] --> B[Load Balancer]
    
    B --> C[Web Server 1<br/>nginx]
    B --> D[Web Server 2<br/>nginx]
    
    C --> E[App Server<br/>Node.js]
    D --> E
    
    E --> F[Database Primary<br/>PostgreSQL]
    E --> G[Cache<br/>Redis]
    
    F --> H[Database Replica<br/>Read Only]
    
    style A fill:#ff9999
    style B fill:#99ccff
    style C fill:#99ff99
    style D fill:#99ff99
    style E fill:#ffcc99
    style F fill:#cc99ff
    style G fill:#ffff99
    style H fill:#ccccff
----

=== コード例：セキュリティ実装

.JWT認証の実装
[source,java]
----
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtTokenProvider tokenProvider;
    private final UserDetailsService userDetailsService;
    
    public JwtAuthenticationFilter(JwtTokenProvider tokenProvider, 
                                  UserDetailsService userDetailsService) {
        this.tokenProvider = tokenProvider;
        this.userDetailsService = userDetailsService;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        String token = extractTokenFromRequest(request);
        
        if (token != null && tokenProvider.validateToken(token)) {
            String username = tokenProvider.getUsernameFromToken(token);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            
            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());
                    
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
----

=== テストコード例
.テストコード例
[source,java]
----
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class UserServiceIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    @DisplayName("ユーザー作成が正常に動作すること")
    void shouldCreateUserSuccessfully() {
        // Given
        CreateUserRequest request = CreateUserRequest.builder()
                .username("testuser")
                .email("test@example.com")
                .password("password123")
                .build();
        
        // When
        UserDto result = userService.create(request);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getUsername()).isEqualTo("testuser");
        assertThat(result.getEmail()).isEqualTo("test@example.com");
        assertThat(result.getId()).isNotNull();
        
        // データベースに保存されていることを確認
        Optional<User> savedUser = userRepository.findById(result.getId());
        assertThat(savedUser).isPresent();
        assertThat(savedUser.get().getPassword()).isNotEqualTo("password123"); // ハッシュ化されている
    }
    
    @Test
    @DisplayName("存在しないユーザーIDで検索時に例外が発生すること")
    void shouldThrowExceptionWhenUserNotFound() {
        // Given
        Long nonExistentId = 999L;
        
        // When & Then
        assertThatThrownBy(() -> userService.findById(nonExistentId))
                .isInstanceOf(UserNotFoundException.class)
                .hasMessageContaining("User not found: 999");
    }
}
----



== 第4章: 結果と評価

=== 期待される効果

[cols="3*", options="header"]
|===
|指標 |現在 |改善後

|効率
|60%
|*85%*

|コスト
|120%
|*90%*

|品質
|3.2
|*4.5*
|===

=== 効果の可視化

.パフォーマンス比較チャート
[cols="3,2,2", options="header"]
|===
|項目 |改善前 |改善後

|効率
|60%
|*85%*

|コスト（削減率）
|20%
|*90%*

|品質スコア
|32点
|*45点*

|セキュリティ
|45点
|*80点*

|保守性
|40点
|*75点*
|===

.ROI分析
[cols="2,1", options="header"]
|===
|効果項目 |割合

|開発コスト削減
|35%

|運用コスト削減
|25%

|品質向上効果
|20%

|セキュリティ向上
|15%

|その他
|5%
|===



== まとめ

=== 重要なポイント

[%step]
. 問題を明確に定義した
. 実現可能な解決策を提示した
. 段階的な実装計画を立てた
. 測定可能な成果を設定した

=== 次のステップ

* プロジェクト承認
* チーム編成
* 開発開始



== Q&A

[.text-center]
*ご質問をお待ちしています*

[.notes]
--
質疑応答の時間です。
どんな質問でもお気軽にどうぞ。
--
